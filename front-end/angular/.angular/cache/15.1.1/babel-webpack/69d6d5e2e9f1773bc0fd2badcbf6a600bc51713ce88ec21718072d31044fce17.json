{"ast":null,"code":"export const empty = () => null;\nexport const from = value => value ? {\n  value\n} : empty();\nexport function isEmpty(mb) {\n  // export function isEmpty<T>(mb: Maybe<T>): mb is Empty<T> {\n  return mb === null || mb === undefined;\n}\nexport function hasValue(mb) {\n  return mb !== null && mb !== undefined && mb['value'] !== undefined;\n}\nexport function formatDate(date) {\n  return date.toISOString();\n}\nexport const addOrReplaceBetweenDatesFilter = (startDateColumn, stopDateColumn) => (startValue, stopValue, filtering) => {\n  return [...(filtering && filtering.length > 0 ? filtering.filter(f => f.column !== startDateColumn && f.column !== stopDateColumn) : []), {\n    column: startDateColumn,\n    kind: 'DATE',\n    predicate: 'GE',\n    value: startValue,\n    prefix: ''\n  }, {\n    column: stopDateColumn,\n    kind: 'DATE',\n    predicate: 'LE',\n    value: stopValue,\n    prefix: ''\n  }];\n};\nexport const addOrReplaceGEDateFilter = (startDateColumn, stopDateColumn) => (startValue, filtering) => {\n  return [...(filtering && filtering.length > 0 ? filtering.filter(f => f.column !== startDateColumn && f.column !== stopDateColumn) : []), {\n    column: startDateColumn,\n    kind: 'DATE',\n    predicate: 'GE',\n    value: startValue,\n    prefix: ''\n  }];\n};\nexport const addOrReplaceLEDateFilter = (startDateColumn, stopDateColumn) => (startValue, filtering) => {\n  return [...(filtering && filtering.length > 0 ? filtering.filter(f => f.column !== startDateColumn && f.column !== stopDateColumn) : []), {\n    column: stopDateColumn,\n    kind: 'DATE',\n    predicate: 'LE',\n    value: startValue,\n    prefix: ''\n  }];\n};","map":{"version":3,"mappings":"AAMA,OAAO,MAAMA,KAAK,GAAsB,MAAM,IAAI;AAClD,OAAO,MAAMC,IAAI,GAA+BC,KAAK,IAAKA,KAAK,GAAG;EAAEA;AAAK,CAAE,GAAGF,KAAK,EAAE;AAErF,OAAM,SAAUG,OAAO,CAAIC,EAAY;EACvC;EACI,OAAOA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAKC,SAAS;AAC1C;AACA,OAAM,SAAUC,QAAQ,CAAIF,EAAY;EACpC,OAAOA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAKC,SAAS,IAAID,EAAE,CAAC,OAAO,CAAC,KAAKC,SAAS;AACvE;AAEA,OAAM,SAAUE,UAAU,CAACC,IAAU;EACjC,OAAOA,IAAI,CAACC,WAAW,EAAE;AAC7B;AAEA,OAAO,MAAMC,8BAA8B,GAEE,CAACC,eAAe,EAAEC,cAAc,KAChC,CAACC,UAAkB,EAAEC,SAAiB,EAACC,SAAuB,KAAI;EAE7G,OAAO,CACH,IAAIA,SAAS,IAAIA,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGD,SAAS,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,KAAKR,eAAe,IAAIO,CAAC,CAACC,MAAM,KAAKP,cAAc,CAAC,GAAG,EAAE,CAAC,EAChI;IAAEO,MAAM,EAAER,eAAe;IAAES,IAAI,EAAE,MAAM;IAAEC,SAAS,EAAE,IAAI;IAAEnB,KAAK,EAAEW,UAAU;IAAES,MAAM,EAAE;EAAE,CAAc,EACrG;IAAEH,MAAM,EAAEP,cAAc;IAAEQ,IAAI,EAAE,MAAM;IAAEC,SAAS,EAAE,IAAI;IAAEnB,KAAK,EAAEY,SAAS;IAAEQ,MAAM,EAAE;EAAE,CAAc,CACtG;AACH,CAAC;AAED,OAAO,MAAMC,wBAAwB,GACC,CAACZ,eAAe,EAAEC,cAAc,KAAK,CAACC,UAAU,EAAEE,SAAS,KAAI;EAEjG,OAAO,CACH,IAAIA,SAAS,IAAIA,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGD,SAAS,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,KAAKR,eAAe,IAAIO,CAAC,CAACC,MAAM,KAAKP,cAAc,CAAE,GAAG,EAAE,CAAC,EACjI;IAAEO,MAAM,EAAER,eAAe;IAAES,IAAI,EAAE,MAAM;IAAEC,SAAS,EAAE,IAAI;IAAEnB,KAAK,EAAEW,UAAU;IAAES,MAAM,EAAE;EAAE,CAAc,CACxG;AACL,CAAC;AAED,OAAO,MAAME,wBAAwB,GACE,CAACb,eAAe,EAAEC,cAAc,KAAK,CAACC,UAAU,EAAEE,SAAS,KAAI;EAElG,OAAO,CACH,IAAIA,SAAS,IAAIA,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGD,SAAS,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,KAAKR,eAAe,IAAIO,CAAC,CAACC,MAAM,KAAKP,cAAc,CAAC,GAAG,EAAE,CAAC,EAChI;IAAEO,MAAM,EAAEP,cAAc;IAAEQ,IAAI,EAAE,MAAM;IAAEC,SAAS,EAAE,IAAI;IAAEnB,KAAK,EAAEW,UAAU;IAAES,MAAM,EAAE;EAAE,CAAc,CACvG;AACL,CAAC","names":["empty","from","value","isEmpty","mb","undefined","hasValue","formatDate","date","toISOString","addOrReplaceBetweenDatesFilter","startDateColumn","stopDateColumn","startValue","stopValue","filtering","length","filter","f","column","kind","predicate","prefix","addOrReplaceGEDateFilter","addOrReplaceLEDateFilter"],"sourceRoot":"","sources":["C:\\Users\\andrea\\Desktop\\SIGLA\\tesi\\tesi-andrea-lauretta\\front-end\\angular\\src\\app\\utils.ts"],"sourcesContent":["import { Filtering } from \"./redux/state\";\r\n\r\nexport type Empty<T> = null | undefined;\r\nexport type Full<T> = { value: T };\r\nexport type Maybe<T> = Full<T> | Empty<T>;\r\n\r\nexport const empty: <T>() => Empty<T> = () => null;\r\nexport const from: <T>(value: T) => Maybe<T> = (value) => value ? { value } : empty();\r\n\r\nexport function isEmpty<T>(mb: Maybe<T>): boolean {\r\n// export function isEmpty<T>(mb: Maybe<T>): mb is Empty<T> {\r\n    return mb === null || mb === undefined;\r\n}\r\nexport function hasValue<T>(mb: Maybe<T>): mb is Full<T> {\r\n    return mb !== null && mb !== undefined && mb['value'] !== undefined;\r\n}\r\n\r\nexport function formatDate(date: Date): string {\r\n    return date.toISOString();\r\n}\r\n\r\nexport const addOrReplaceBetweenDatesFilter: <T>(startDateColumn: keyof T, stopDateColumn: keyof T)\r\n                                             => (startValue: string, stopValue: string, filtering?: Filtering[]) => Filtering[]\r\n                                           = (startDateColumn, stopDateColumn) =>\r\n                                             (startValue: string, stopValue: string,filtering?: Filtering[]) =>\r\n{\r\n  return [\r\n      ...(filtering && filtering.length > 0 ? filtering.filter(f => f.column !== startDateColumn && f.column !== stopDateColumn) : []),\r\n      { column: startDateColumn, kind: 'DATE', predicate: 'GE', value: startValue, prefix: ''} as Filtering,\r\n      { column: stopDateColumn, kind: 'DATE', predicate: 'LE', value: stopValue, prefix: ''} as Filtering\r\n  ];\r\n}\r\n\r\nexport const addOrReplaceGEDateFilter: <T>(startDateColumn: keyof T, stopDateColumn: keyof T) => (startValue: string, filtering?: Filtering[]) => Filtering[]\r\n                                    = (startDateColumn, stopDateColumn) => (startValue, filtering) =>\r\n{\r\n    return [\r\n        ...(filtering && filtering.length > 0 ? filtering.filter(f => f.column !== startDateColumn && f.column !== stopDateColumn ) : []),\r\n        { column: startDateColumn, kind: 'DATE', predicate: 'GE', value: startValue, prefix: ''} as Filtering\r\n    ];\r\n}\r\n\r\nexport const addOrReplaceLEDateFilter: <T>(startDateColumn: keyof T, stopDateColumn: keyof T) => (startValue: string, filtering?: Filtering[]) => Filtering[]\r\n                                     = (startDateColumn, stopDateColumn) => (startValue, filtering) =>\r\n{\r\n    return [\r\n        ...(filtering && filtering.length > 0 ? filtering.filter(f => f.column !== startDateColumn && f.column !== stopDateColumn) : []),\r\n        { column: stopDateColumn, kind: 'DATE', predicate: 'LE', value: startValue, prefix: ''} as Filtering\r\n    ];\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}